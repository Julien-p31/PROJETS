# Tutoriel : CrÃ©er un pare-feu personnalisÃ© en Python/iptables

## ðŸŽ¯ Objectif  
DÃ©velopper un pare-feu sur Linux capable de filtrer, bloquer des IP/ports, dÃ©tecter certaines attaques (SYN/ICMP flood), avec logs et rÃ¨gles dynamiques.

## ðŸ§  ScÃ©nario dâ€™ancrage Ã©motionnel  
Vous dÃ©ployez un petit serveur web. Face Ã  une montÃ©e de scans SYN et bots, vous devez crÃ©er un filtre adaptable et visible avant de passer Ã  une solution plus lourde.

---

## ðŸ› ï¸ PrÃ©requis  
- Environnement : Linux (Ubuntu/Debian)  
- Python 3.8+  
- Packages :  
  ```bash
  sudo apt update
  sudo apt install python3-pip iptables
  pip install python-iptables scapy python-netfilterqueue

	â€¢	Privileges : exÃ©cution avec sudo ou root

â¸»

ðŸ§© Ã‰tapeâ€¯1 â€“ Architecture et capture

[Internet] â†’ [SCRIPT PYTHON] â†’ iptables rules â†’ [SERVEUR]

	â€¢	On intercepte les paquets via NFQUEUE sur iptables
	â€¢	Le script Python examine chaque paquet, dÃ©cide ACCEPT, DROP, ou REJECT

â¸»

ðŸ”§ Ã‰tapeâ€¯2 â€“ CrÃ©ation dâ€™une queue Netfilter

ExÃ©cutez :

sudo iptables -I INPUT -j NFQUEUE --queue-num 1

â†’ tous les paquets entrent dans la file 1 avant dÃ©cision Python.  ï¿¼ ï¿¼ ï¿¼

â¸»

ðŸ§© Ã‰tapeâ€¯3 â€“ Script Python de filtrage

import netfilterqueue, scapy.all as sc

def process(pkt):
    ip = sc.IP(pkt.get_payload())
    if ip.proto == 6 and ip[TCP].flags == "S" and ip[TCP].sport == 12345:
        pkt.drop()
        print("BloquÃ© SYN depuis port 12345")
    else:
        pkt.accept()

nfq = netfilterqueue.NetfilterQueue()
nfq.bind(1, process)
try:
    nfq.run()
except KeyboardInterrupt:
    print("ArrÃªt")

	â€¢	RÃ©cupÃ¨re paquets via NFQUEUE
	â€¢	Analyse protocole et flags TCP
	â€¢	Accepte ou bloque en streaming ()

â¸»

ðŸ§© Ã‰tapeâ€¯4 â€“ Logging et attaques SYN-flood

Modifiez process :

count = {}

def process(pkt):
    ip = sc.IP(pkt.get_payload())
    src = ip.src
    count[src] = count.get(src,0) + 1
    if count[src] > 100:
        pkt.drop()
        print(f"{src} bloquÃ© {count[src]} requÃªtes")
    else:
        pkt.accept()

â†’ empÃªche un seul client de saturer le serveur.

â¸»

ðŸ§© Ã‰tapeâ€¯5 â€“ GÃ©nÃ©ration de rÃ¨gles dynamiques

Installer iptables bindings en Python :

import iptc

def block_ip(ip):
    rule = iptc.Rule()
    rule.src = ip
    rule.target = iptc.Target(rule, "DROP")
    iptc.Table(iptc.Table.FILTER).chains[0].insert_rule(rule)

â†’ ajoute une rÃ¨gle statique dans la table INPUT  ï¿¼

â¸»

ðŸ§© Ã‰tapeâ€¯6 â€“ Scanning ICMP floods

Dans process, ajoutez :

if ip.proto == 1 and len(ip.payload) > 512:
    pkt.drop()
    print(f"ICMP gros paquet bloquÃ© de {ip.src}")

â†’ filtrage basique des attaques ping flood.

â¸»

ðŸ§© Ã‰tapeâ€¯7 â€“ Orchestration CLI

import argparse

# ... dÃ©finir arguments --start, --stop, --block-ip <IP> ...
# Utiliser subprocess pour lancer script NFQUEUE, init rules, nettoyages

	â€¢	Lancez en mode daemon ou foreground

â¸»

ðŸ§  Ã‰tapeâ€¯8 â€“ SÃ©curitÃ© & robustesse
	â€¢	ProtÃ©gez le daemon (ex. via systemd)
	â€¢	GÃ©rez les exceptions (try/except)
	â€¢	Nettoyez rÃ¨gles iptables Ã  la fin
	â€¢	Sauvegardez logs: logging Python, rotation journaliÃ¨re

â¸»

ðŸ§ª Quiz de consolidation
	1.	Pourquoi utiliser NFQUEUE plutÃ´t que snifferâ€¯?
	2.	Comment empÃªcher un SYN floodâ€¯?
	3.	Pourquoi ajouter iptables bindings statiquement ?
	4.	Un paquet ICMP volumineux indique-t-il toujours une attaqueâ€¯?
	5.	Que nettoie-t-on Ã  la fin du scriptâ€¯?

â¸»

âœ… Cas dâ€™usage
	â€¢	Serveur web ou IoT exposÃ©
	â€¢	Protection contre scans aux heures creuses
	â€¢	DÃ©tection initiale avant WAF ou IPS

â¸»

ðŸ”§ Extensions possibles
	â€¢	IntÃ©grer Suricata + logs JSON pour bloc automatique  ï¿¼ ï¿¼ ï¿¼ ï¿¼ ï¿¼
	â€¢	Interface graphique minimaliste avec tkinter (ex. OpenFirewall) ()
	â€¢	Passer de iptables Ã  nftables avec python-nftables
	â€¢	Mode apprentissage : crÃ©er rÃ¨gles basÃ©es sur le trafic normal

â¸»

ðŸŽ“ RÃ©sultat attendu
	â€¢	Pare-feu Python fonctionnel, filtrant TCP/ICMP, logs dynamiques
	â€¢	Protection contre reconnaissances et floods simples
	â€¢	Base claire pour Ã©voluer vers solution IPSâ„¢

---

### ðŸ“š Sources  
- Projet Python + iptables + scapy + flood detection  [oai_citation:9â€¡GitHub](https://github.com/Sharanabasavas/Firewall-Implementation?utm_source=chatgpt.com) [oai_citation:10â€¡GitHub](https://github.com/akshay-onfroy/Python-Firewall-with-Real-time-Threat-Detection?utm_source=chatgpt.com) [oai_citation:11â€¡charlysuarezcybersecurityportfolio.online](https://charlysuarezcybersecurityportfolio.online/automatically-blocking-malicious-ips-with-python-and-suricata-logs/?utm_source=chatgpt.com)  
- Utilisation de NFQUEUE + netfilterqueue en Python  [oai_citation:12â€¡GitHub](https://github.com/parag290/Firewall-for-Linux-using-Python?utm_source=chatgpt.com)  
- ContrÃ´le iptables via Python binding `python-iptables` ()  
- IntÃ©gration avec Suricata pour bloc IP automatique  [oai_citation:13â€¡wroberts.me](https://wroberts.me/?p=741&utm_source=chatgpt.com)  
- Exemples de GUI firewall Python (OpenFirewall, Firewalld, UFW)  [oai_citation:14â€¡Wikipedia](https://en.wikipedia.org/wiki/Firewalld?utm_source=chatgpt.com)