# Tutoriel : D√©velopper une application web s√©curis√©e

## üéØ Objectif  
Cr√©er de A √† Z une application web simple (avec Flask + SQLite), int√©grant la s√©curit√© d√®s la conception (SDLC), selon les meilleures pratiques OWASP, et d√©ployable en local avec HTTPS.

---

## üß† Sc√©nario √©motionnel  
Vous d√©veloppez un service interne pour la PME o√π vous travaillez. Un audit r√©v√®le des failles. Vous devez reconstruire l‚Äôapp d√®s le d√©but, en suivant des r√®gles rigoureuses, pour √©viter les fuites de donn√©es.

---

## ‚öôÔ∏è Pr√©requis  
- Linux/VM avec Python 3.8+, git  
- Modules :  
  ```bash
  pip install flask flask‚Äëlogin flask‚Äëwtf flask‚Äëtalisman sqlalchemy cryptography pyjwt

	‚Ä¢	Connaissance basique de Flask/HTML

‚∏ª

üß© √âtape 1 ‚Äì Planification & architecture
	1.	Structure minimaliste :
	‚Ä¢	Front (HTML/JS)
	‚Ä¢	Back (Flask + API REST)
	‚Ä¢	Base SQLite
	2.	Appliquer la s√©paration logique : front, back, data  Ôøº Ôøº
	3.	D√©finir les menaces : injection, XSS, CSRF, fuite de donn√©es de sessions, mauvaise config TLS.

‚∏ª

üîê √âtape 2 ‚Äì Cr√©ation du squelette Flask

# app.py
from flask import Flask, render_template, request, redirect, url_for, flash
from flask_wtf import FlaskForm
from wtforms import StringField, PasswordField
from wtforms.validators import DataRequired
from flask_login import LoginManager, login_user, login_required, logout_user, UserMixin
import sqlalchemy

app = Flask(__name__, template_folder="templates")
app.config.update(
  SECRET_KEY="change_this_securely!",
  WTF_CSRF_ENABLED=True,
  SESSION_COOKIE_SECURE=True,
  REMEMBER_COOKIE_HTTPONLY=True
)
# Activer HTTPS HSTS
from flask_talisman import Talisman
Talisman(app)

# Base de donn√©es
engine = sqlalchemy.create_engine("sqlite:///users.db")
# √† compl√©ter : ORM / tables user

login_manager = LoginManager(app)

‚úîÔ∏è HTTPS+HSTS : s√©curise transport d√®s le d√©but.

‚∏ª

üß† √âtape 3 ‚Äì Mod√®le utilisateur et authentification

# suite app.py
from werkzeug.security import generate_password_hash, check_password_hash

class User(UserMixin):
  # attributs : id, username, pw_hash
  def verify_password(self, pwd):
    return check_password_hash(self.pw_hash, pwd)

# Routes :
@app.route("/login", methods=["GET","POST"])
def login():
  form = LoginForm()
  if form.validate_on_submit():
    u = ... # rechercher user dans la BDD
    if u and u.verify_password(form.password.data):
      login_user(u)
      return redirect(url_for("dashboard"))
    flash("Identifiants invalides", "error")
  return render_template("login.html", form=form)

@app.route("/dashboard")
@login_required
def dashboard():
  return "Bienvenue, s√©curis√© !"

	‚Ä¢	Hash des mots de passe avec werkzeug (PBKDF2)
	‚Ä¢	Protection CSRF int√©gr√©e via WTForms

‚∏ª

üß© √âtape 4 ‚Äì Validation & encodage des entr√©es

class CommentForm(FlaskForm):
  comment = StringField("Commentaire", validators=[DataRequired(), Length(max=200)])

@app.route("/comment", methods=["POST"])
@login_required
def comment():
  form = CommentForm()
  if form.validate_on_submit():
    safe = escape(form.comment.data)  # suppression HTML
    # sauvegarder en DB

	‚Ä¢	Utilisation de validateurs Length, DataRequired, etc.
	‚Ä¢	√âchappement syst√©matique du HTML = pr√©vention XSS  Ôøº Ôøº

‚∏ª

üß† √âtape 5 ‚Äì Journaux et surveillance

import logging
handler = logging.FileHandler("app.log")
handler.setLevel(logging.INFO)
app.logger.addHandler(handler)

	‚Ä¢	Conserver logs (authentification, input invalides) ()
	‚Ä¢	Pr√©voir monitoring (e.g. en production via SIEM)

‚∏ª

üõ° √âtape 6 ‚Äì S√©curit√© des API (JWT, permissions)

import jwt, datetime
SECRET = "another_secret_change_me"

@app.route("/api/data", methods=["GET"])
def api_data():
  token = request.headers.get("Authorization", "").split("Bearer ")[-1]
  try:
    payload = jwt.decode(token, SECRET, algorithms=["HS256"])
  except jwt.PyJWTError:
    abort(401)
  return jsonify({"msg":"ok", "user":payload["sub"]})

	‚Ä¢	Auth via JWT dans les headers
	‚Ä¢	Validation de permissions avant chaque appel = principe d‚Äôauthorization  Ôøº Ôøº

‚∏ª

üîê √âtape 7 ‚Äì Hardening serveur
	‚Ä¢	Forcer HTTPS & HSTS via Flask-Talisman
	‚Ä¢	En t√™te HTTP stricte (X-Frame-Options, CSP, X-Content-Type-Options) g√©r√©es par Talisman
	‚Ä¢	Recommandations DevSecOps : mise √† jour, d√©pendances scann√©es, minimalisme du serveur  Ôøº

‚∏ª

üß™ √âtape 8 ‚Äì Tests automatis√©s
	‚Ä¢	Scanner statique avec bandit
	‚Ä¢	Tests unitaires avec pytest, v√©rifier r√©ponses inject√©es, no SQL injection, sesseions
	‚Ä¢	Patcher selon OWASP Top10 (A1-A10)  Ôøº Ôøº

‚∏ª

üß† R√©sum√© des bonnes pratiques OWASP
	‚Ä¢	Validation entr√©e + encodage sortie
	‚Ä¢	Auth et gestion de session s√©curis√©es
	‚Ä¢	Journaux prot√©g√©s
	‚Ä¢	Configuration TLS stricte
	‚Ä¢	S√©curiser les d√©pendances & pipeline de CI/CD  Ôøº

‚∏ª

üß™ Quiz de consolidation
	1.	Pourquoi activer HSTS d√®s la mise en production ?
	2.	Quel risque √©vite escape() dans les templates ?
	3.	Comment prot√©ger une API REST avec JWT ?
	4.	Pourquoi logger les connexions avec niveau INFO ?
	5.	Que contient un scan Bandit ?

‚∏ª

üß© Extensions possibles
	‚Ä¢	Ajout 2FA (TOTP) pour acc√®s
	‚Ä¢	Int√©grer WAF comme ModSecurity  Ôøº Ôøº
	‚Ä¢	Containeriser avec Docker + scanner d‚Äôimages
	‚Ä¢	D√©ploiement automatis√© avec CI/CD incluant tests de s√©curit√©

‚∏ª

üéì R√©sultat attendu
	‚Ä¢	App Flask simple avec login, commentaires, API
	‚Ä¢	Protection CSRF, contenus √©chapp√©s, JWT valid√©s
	‚Ä¢	HTTPS + en-t√™tes s√©curis√©s
	‚Ä¢	Logs d‚Äôacc√®s + pipeline de test et scanning statique

---

Sources principales :  
‚Äì OWASP Secure Coding & Top10  [oai_citation:12‚Ä°coursera.org](https://www.coursera.org/learn/web-application-security?utm_source=chatgpt.com) [oai_citation:13‚Ä°codesigningstore.com](https://codesigningstore.com/owasps-secure-coding-practices-checklist?utm_source=chatgpt.com)  
‚Äì D√©ploiement s√©curis√© via HTTPS/TLS ()  
‚Äì WAF et ModSecurity  [oai_citation:14‚Ä°Wikipedia](https://en.wikipedia.org/wiki/ModSecurity?utm_source=chatgpt.com)  
‚Äì DevSecOps, pipelines & hardening ()